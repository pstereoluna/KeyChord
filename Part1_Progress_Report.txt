PROGRESS REPORT - KeyChord Virtual Piano Project
==================================================

(a) Brief, updated summary of what the project will do
------------------------------------------------------
KeyChord is a Java Swing application that provides an 
interactive virtual piano with recording and playback capabilities. 
The application allows users to:

- Play piano notes using a two-row computer keyboard layout or mouse clicks
- Generate and play chords automatically (8 chord types: Major, Minor, 
  Diminished, Augmented, Major 7th, Minor 7th, Sus2, Sus4)
- Record musical performances with timestamps
- Play back recordings with visual key synchronization
- Manage multiple recordings (save, rename, delete, export to MIDI files)
- Export recordings as standard MIDI (.mid) files

The project demonstrates strict MVC architecture, SOLID principles, and 
comprehensive unit testing using JUnit 5 and Mockito.


(b) Which aspects of OOD will be evident in your solution and presentation
--------------------------------------------------------------------------
The following Object-Oriented Design principles are evident throughout:

1. MVC Architecture: Strict separation of Model (business logic), View 
   (Swing UI), and Controller (event handling and coordination)

2. SOLID Principles:
   - Single Responsibility: Each class has one clear purpose (e.g., ChordManager 
     only generates chords, Recorder only handles recording timestamps)
   - Open/Closed: ChordManager uses enum-based strategy pattern for extensible 
     chord types
   - Liskov Substitution: Player.EventSource interface allows Recording and 
     Track to be used interchangeably
   - Interface Segregation: KeyPressHandler interface provides minimal, focused 
     contract
   - Dependency Inversion: Controllers depend on Model interfaces, not concrete 
     implementations

3. Design Patterns:
   - Singleton: MidiSoundManager ensures single synthesizer instance
   - Strategy: ChordType enum for different chord generation algorithms
   - Adapter: RecordingEventSource adapts Recording to Player.EventSource
   - Observer: KeyListener and ActionListener for event-driven architecture

4. Abstraction: Interfaces (EventSource, NotePlaybackHandler, KeyPressHandler) 
   hide implementation details

5. Encapsulation: All model classes use private fields with controlled access 
   through methods

6. Delegation over Inheritance: Controllers delegate to model methods rather 
   than extending view components

7. Composition: PianoModel composes multiple managers (RecordingManager, 
   ChordManager, etc.) rather than inheriting functionality


(c) Which member(s) of the instructional team have you spoken with about this version?
--------------------------------------------------------------------------------------
Spoke with TA Jingjing during recitation on 20 November."


(d) Whether or not the instructor/TA indicated that the project seems feasible 
    (not overly ambitious) and aligned with CS5004 objectives
-------------------------------------------------------------------------------
Yes. The TA indicated that the project is feasible and well aligned with CS5004 objectives. 
She noted strong motivation and a solid OOD foundation, supported the MVP-first approach, 
and suggested beginning to design the Controller and View. She also reminded us that 
testing musical software can be tricky, so a clear unit-testing plan—starting with the 
most testable components—will be important.


(e) Rough sketch of a Class Diagram
-----------------------------------
Major classes and their relationships:

MODEL LAYER (Business Logic):
- PianoModel (concrete class)
  - Uses: Recorder, Player, MidiSoundManager, ChordManager, RecordingManager
  
- ChordManager (concrete class)
  - Contains: ChordType (enum with intervals)
  
- RecordingManager (concrete class)
  - Manages: Recording (concrete class)
  
- Recording (concrete class)
  - Contains: List<NoteEvent>
  
- NoteEvent (concrete class, immutable data class)
  
- Recorder (concrete class)
  - Creates: NoteEvent objects
  
- Player (concrete class)
  - Uses: EventSource (interface)
  - Uses: NotePlaybackHandler (interface)
  
- MidiSoundManager (concrete class, singleton)
  
- KeyMappings (utility class, static methods)

VIEW LAYER (Swing UI):
- MainWindow (extends JFrame)
  - Contains: PianoView
  
- PianoView (extends JPanel)
  - Contains: PianoKeyboardPanel, ControlPanelView, RecordingPanel
  
- PianoKeyboardPanel (extends JPanel)
  - Contains: Map<Integer, PianoKeyView>
  - Uses: KeyPressHandler (interface)
  
- PianoKeyView (extends JButton)
  
- ControlPanelView (extends JPanel)
  
- RecordingPanel (extends JPanel)

CONTROLLER LAYER:
- PianoController (implements KeyListener, ActionListener)
  - Coordinates: PianoModel, PianoView
  
- RecordingController (implements KeyListener, ActionListener)
  - Coordinates: PianoModel, PianoView
  
- PlaybackController (implements KeyListener, ActionListener)
  - Coordinates: PianoModel, PianoView
  
- RecordingPanelController (implements ActionListener)
  - Coordinates: PianoModel, PianoView

INTERFACES:
- Player.EventSource (interface)
  - Implemented by Recording (via adapter)
  
- Player.NotePlaybackHandler (interface)
  
- PianoKeyboardPanel.KeyPressHandler (interface)

ENTRY POINT:
- KeyChordApp (main class)


(f) The final list of Team Members working with you on the project
------------------------------------------------------------------
Jiaxin Jia, Xiaoyuan Lu


(g) Roughly how many lines of Java code do you anticipate in your final submission?
-----------------------------------------------------------------------------------
Based on current implementation:
- Source code: Approximately 1,800 lines
- Test code: Approximately 1,600 lines
- Total: Approximately 3,400 lines


(h) How many distinct files do you think will be involved, not counting presentation materials?
----------------------------------------------------------------------------------------------
Source files:
- Model classes: 9 files
- View classes: 6 files
- Controller classes: 4 files
- Entry point: 1 file
Total source: 20 Java files

Test files:
- Model tests: 9 files
- View tests: 3 files
- Controller tests: 4 files
Total tests: 16 Java test files

Configuration:
- pom.xml: 1 file

Total: **37 files** (20 source + 16 test + 1 config)


(i) How many lines of non-Java code, if any, do you anticipate being required?
------------------------------------------------------------------------------
Non-Java code:
- pom.xml (Maven configuration): ~60 lines
- README.md (documentation): ~200 lines

Total: Approximately 160 lines of non-Java code (mostly documentation)


(j) If you plan to avail of the allowed "up to 20%" AI-generated code, what will it be for?
------------------------------------------------------------------------------------------
I plan to use AI assistance (approximately 15% of codebase, ~500 lines) for:
- Initial project structure setup and boilerplate code
- JUnit test templates and mock setup code
- JavaDoc comment generation for standard getter/setter methods
- Maven pom.xml dependency configuration

All AI-generated code will be reviewed, tested, and understood before 
submission. Core business logic (chord generation, recording, playback) 
will be written manually.


(k) Focus on highlighting your use of OOD principles
---------------------------------------------------
In addition to "testable" and "tested" code, and Javadocs for every file 
and method, the following OOD principles are visible in the code:

1. Abstraction: 
   - EventSource interface abstracts the source of NoteEvents (Recording, Track)
   - NotePlaybackHandler interface abstracts playback behavior
   - KeyPressHandler interface abstracts key input handling

2. Single Responsibility Principle (SOLID):
   - ChordManager: Only generates chords, no audio or UI logic
   - Recorder: Only manages recording timestamps, no playback logic
   - MidiSoundManager: Only handles MIDI audio, no recording/playback logic
   - Each controller handles one specific aspect (piano input, recording, playback)

3. Open/Closed Principle (SOLID):
   - ChordManager can be extended with new ChordType enum values without 
     modifying existing code
   - Player can accept any EventSource implementation without modification

4. Interface Segregation Principle (SOLID):
   - KeyPressHandler has minimal interface (only onKeyPressed/onKeyReleased)
   - NotePlaybackHandler separates note-on and note-off concerns

5. Dependency Inversion Principle (SOLID):
   - Controllers depend on PianoModel interface, not concrete implementations
   - Player depends on EventSource interface, not concrete Recording/Track

6. Delegation over Inheritance:
   - Controllers delegate to model methods rather than extending view components
   - PianoModel delegates to specialized managers (RecordingManager, ChordManager)

7. Composition over Inheritance:
   - PianoModel composes multiple managers rather than inheriting functionality
   - PianoView composes multiple panels (keyboard, control, recording)

8. Encapsulation:
   - All model classes use private fields with controlled access
   - Thread-safe synchronization in Recording, RecordingManager, Recorder

9. Separation of Concerns:
    - Model has zero Swing dependencies (pure business logic)
    - View has zero business logic (pure UI)
    - Controllers mediate without containing business logic


These principles ensure the code is robust, extensible, maintainable, and 
testable with minimal redundant coding.


